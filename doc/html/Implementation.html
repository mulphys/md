<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ReMoDy: Implementation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="Implementation">Implementation </a></h1><h2><a class="anchor" name="SecImpl">
Implementation</a></h2>
<h3><a class="anchor" name="SColDet">
Collision Detection Scheme</a></h3>
The discretization scheme is based on the combination of the linked cell method (Sec.<a class="el" href="Implementation.html#SLinkCell">Linked-Cell Method</a>) with a space-time collision detection scheme (Sec.<a class="el" href="Implementation.html#STDetAlg">Space-Time Collision Detection Scheme</a> ), which enable to significantly accelerate the execution of the method. To better understand the principle of the method, it has to be compared with the standard time-advancement scheme.<h4><a class="anchor" name="StdAlg">
Standard Time-Advancement Scheme</a></h4>
In a standard scheme all molecules are advanced using a single global time step. This time step is selected as the minimum time for a molecule to move at the distance of its radius:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ dt = \frac{d}{v} \]" src="form_47.png">
<p>
<p>
where 'd' is the on the order of molecule radius and 'v' is the velocity of a molecule. The minimum is sought for all molecules. After each time step the relative positions of all molecules are analyzed to determine if there are any overlaps (collisions) between pairs of molecules.<p>
This choice of time-step, dt, above guarantees that no molecule will miss a collision event. However, since each molecule usually travels much longer distances than its length between the collisions, this scheme leads to unnecessary many steps calculations for an essentially straight trajectory path between the collisions as illustrated in the figure below.<p>
<div align="center">
<img src="stepping.png" alt="stepping.png">
<p><strong>Standard time-stepping involves many unnecessary calculations</strong></p></div>
<p>
Also, the time step is selected with respect to the smallest molecule, which usually also have the highest velocity. Thus, in the case of a gas mixture, this time-step will be excessively small for bigger and slower moving molecules.<p>
Considering this, and the fact that the molecules travel on straight paths between the collisions, the standard scheme is very inefficient, since it does the majority of computations for molecules undergoing no collisions, but rather traveling on straight paths.<h4><a class="anchor" name="STDetAlg">
Space-Time Collision Detection Scheme</a></h4>
In the new collision detection scheme instead of moving all molecules with the same time step, attempts to move each molecule directly to the site of next collision, avoiding any calculations on the straight path, as shown in the figure.<p>
<div align="center">
<img src="coldet.png" alt="coldet.png">
<p><strong>Collision detection moves molecule directly to the site of next collision</strong></p></div>
<p>
using a single global time step for all molecules, each molecule has it's own time, and its own time-step. Thus, instead of a 3D position vector and velocity vector, the kinematic parameters for each molecule include a 4D space-time vector (x,y,z,t), velocity vector, (vx,vy,vz) and the time step, dt. The time-step for each molecule is is calculated as the time to the next collision. Thus, one can estimate the time of the next collision event, <img class="formulaInl" alt="$t_{coll}$" src="form_48.png">, for each molecule by adding its current time to its current time step:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ t_{coll} = t + dt \]" src="form_49.png">
<p>
<p>
The time-steps of molecules are constantly updated within the loop, where all pairs of molecules are analyzed for possible collisions on the basis of their velocities and radii. If the molecules are found to be heading for a collision, then the time of that collision event is compared to the currently estimated next collision time for each molecule. The time-steps for the molecules are updated if the new collision event is found to occur earlier than both estimated collision events for each molecule. This results in selection of the earliest possible collision events. The collision events also include the collisions with the walls.<p>
In the same loop where the molecular time-steps are updated using collision-detection scheme, the actual collision events are processed for those molecules which are found to be within the interaction distance from each other. In the course of collision molecules change their velocities in compliance to momentum and energy conservation, as well as exchange their kinetic and internal energies according to the equipartition principle, that is, the total energy is equally distributed among the combined degrees of freedom of two molecules.<p>
After the time-steps of all molecules are updated and collisions processed in the collision-detection loop, the molecules enter the time-advance loop, where each molecule is advanced by its time-step to its nearest collision event. These two loops are iterated over and over until the termination time for the simulation.<p>
It should be noted, that the described scheme will not work well, if the times of all molecules start deviate from each other by too large a value, causing some molecules to go too far ahead in time compared with other molecules. Thus, it is necessary to periodically synchronize the molecules, by bringing them all to the same time level. This is done by introducing the global time step, such that all the molecules exceeding the next global time level will not move to the next collisions until all the molecules reach that time level. Then the global time level is incremented by the global time-step and the procedure is repeated. The value of the global time step is selected on the order of molecular mean-free-path:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ dt = \frac{D}{v} \]" src="form_50.png">
<p>
<p>
where 'D' is on the order of several mean free-path lengths (or inter-molecular distances). This choice guarantees that the molecular collision times will not go out of sync by too much to cause miscalculations in collision events.<p>
Even though the current scheme is still relying on a global time-step, this time step is by far larger than that used in the standard time-stepping scheme discussed above. This is because in the standard scheme the global time-step is based on molecular size, and in the current scheme it is based on inter-molecular distance, which is far larger than the size of the molecule: <img class="formulaInl" alt="$D >> d $" src="form_51.png">. This leads to significant speed-up of calculations compared to the standard time-advance scheme.<h3><a class="anchor" name="SLinkCell">
Linked-Cell Method</a></h3>
ReMoDy uses interaction acceleration scheme based on linked-cell technique, which is a variant of <a href="http://en.wikipedia.org/wiki/Verlet_list">Verlet list method</a> [Verlet L (1967). <em>Phys. Rev.</em> <b>159:</b> 98-103]. In this method the whole computational domain is divided into box-shaped cells. Only interactions between the molecules from the same or adjacent cells are considered (see Figure).<p>
<div align="center">
<img src="linkedcells.png" alt="linkedcells.png">
<p><strong>Grid of Cells for Local Interaction Acceleration</strong></p></div>
<p>
The size of the grid cells is selected by optimizing the execution speed, and is usually on the order of several mean-free-paths. The method enables to achieve near linear dependence of execution time on the number of molecules. In contrast, looping over all molecules makes execution time proportional to the square of the number of molecules, which makes that impractical for large number of molecules.<h3><a class="anchor" name="SOMP">
Multi-Processor Implementation</a></h3>
The code can be made to run in parallel on multi-core workstations. It uses the shared-memory OpenMP library to distribute processing of the molecules time-advancement and interaction loops among the available CPUs.<p>
The two time-critical loops which run in parallel are time-advancement loop, implemented in subroutine <a class="el" href="classDomain.html#9ca54d0631f30e5094f3843845821e5b">Domain::step()</a>, and interaction loop implemented in <a class="el" href="classDomain.html#567821d9c182227ce912ebae35793dd1">Domain::interaction()</a> routine. Before the loops are entered the molecules are indexes sequentially. Each OpenMP thread selects the molecules which has index satisfying the criterion:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ mod(i_{mol}, N_{threads}) = i_{thread} \]" src="form_45.png">
<p>
<p>
where <img class="formulaInl" alt="$mod(*,*)$" src="form_46.png"> is division by modulus. This way all molecules are distributed equally between active threads. The number of threads is selected as the maximum between the available processors, and the pre-defined constant <code>'nthreads'</code>.<p>
In addition to this, in the interaction loop, the locking mechanism is used to prevent simultaneous processing of the same molecules by more than one processor. This can happen because the interaction procedure considers all pairs of molecules, which is done in a double-looping over all molecules. Thus, the selection of molecules from the primary loop, using the mechanism above will not prevent the possibility of simultaneous processing of the same molecule from the secondary loop by more than one processor. The locking mechanism operates by introducing the 'is-locked' flag for each molecule. Inside the nested loop the molecule is considered only when its state is not locked. If this is the case, then the molecule is temporarily locked while its interaction with the primary molecule from the main loop is being processed.<h3><a class="anchor" name="SLists">
Dynamic Lists</a></h3>
The main data-structures holding molecules are dynamic lists: <b><a class="el" href="classCollection.html">Collection</a></b> and <b><a class="el" href="classContainer.html">Container</a></b>. <em><a class="el" href="classCollection.html">Collection</a></em> is a double-linked list of fixed number of items, with two pointers for each item, pointing to the next and the previous item. The list consist of two parts: active and dead. Each part forms a loop, such that following next or previous pointer from any element across the list will lead back to the same element. The procedure of moving elements between the active and dead parts is very simple, involving only several pointer reassignment operations. The figure below illustrates the operation of removing the active molecule from the computational space and assigning it to the pool of "dead" molecules.<p>
<div align="center">
<img src="collection.png" alt="collection.png">
<p><strong>Collection Class</strong></p></div>
<p>
The reverse procedure of "resurrecting" dead molecules and introducing them into the active pool is done in the same manner. This technique enables to avoid expensive memory allocation/deallocation operations, and save time on looping over the list of molecules, since all dead molecules are not in the active list, and are completely ignored by the looping procedure. Thus, no conditional if-statements are necessary, and shorter list sizes can be used.<p>
The <em><a class="el" href="classCollection.html">Collection</a></em> class is convenient for the dynamic storage of a single collection of items, and is used to store all the molecules in the domain.<p>
<em><a class="el" href="classContainer.html">Container</a></em> is a variable size list of pointers to items. Like a <em><a class="el" href="classCollection.html">Collection</a></em> it is also a double-lined list with the next and previous pointers for each item. But unlike a <em><a class="el" href="classCollection.html">Collection</a></em>, the <em><a class="el" href="classContainer.html">Container</a></em> all container lists share the same pool of dead items, or pointers, which can point to any item. Each container list can acquire items from the pool or return them back to the pool.<p>
<div align="center">
<img src="container.png" alt="container.png">
<p><strong>Containter Class</strong></p></div>
<p>
The <em><a class="el" href="classContainer.html">Container</a></em> list is convenient to store multiple lists of items where the number of items constantly change. <a class="el" href="classContainer.html">Container</a> lists are used in the implementation of the linked-cell method described below. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 26 16:10:36 2009 for ReMoDy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
